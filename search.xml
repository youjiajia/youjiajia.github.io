<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>golang学习笔记</title>
      <link href="/undefined.html"/>
      <url>/undefined.html</url>
      <content type="html"><![CDATA[<h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p>引入了关键字var，类型信息放在变量名之后，如：</p><pre><code>var v1 int var v2 *int //指针</code></pre><p>另外，可以若干变量一起声明：</p><pre><code>var {    v1 int    v2 string}</code></pre><p>变量初始化的时候，var关键字可以保留，但不是    必要元素</p><pre><code>var v1 int = 10var v2 = 10 // 编译器自动推导 v2 的类型v3 := 10     // 编译器自动推导    v3的类型</code></pre><p>go编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型，这让go语言看起来有点像动态类型语言，尽管go语言是不折不扣的强类型语言。另外，出现在<code>:=</code>左侧的变量不应该是已经被声明过得，否则会导致编译错误。</p><p>go语言支持多重赋值和多重返回，和python类似：</p><pre><code>i, j = j, i_, _, nickname := GetName()</code></pre><h2 id="go语言中的常量"><a href="#go语言中的常量" class="headerlink" title="go语言中的常量"></a>go语言中的常量</h2><p>常量的定义使用<code>const</code>关键字, 定义时可以限定常量类型，也可以不限制，不限制常量类型的常量是无类型常量，常量定义的右值也可以是一个在编译期运算的常量表达式，比如：<code>const mask = 1 &lt;&lt; 3</code> , 但是常量的右值不能出现需要运行期才能得出结果的表达式，比如<code>const Home = os.GetEnv(&#39;HOME&#39;)</code>,这样会导致编译错误，因为<code>os.GetEnv()</code>只有运行期才能知道返回结果.</p><p>go语言预定义常量有：true,false和iota</p><p>iota可以被认为是一个可被编辑器修改的常量，在每一次const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其代表对的数字就会自动增1.例如：</p><pre><code>const{    c0 = iota // c0 = 1    c1 = iota // c1 = 2    c2 = iota // c2 = 3 }const{ // iota被重置为0    a = 1 &lt;&lt; iota // a = 1    b            // b = 2    c            // c = 4}</code></pre><p>如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。</p><p>另外，同go语言的其他符号(sysbol)一样，以大写字母开头的常量在包外可见。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Go语言内置以下这些基础类型:</p><ul><li>布尔类型:bool。</li><li>整型:int8、byte、int16、int、uint、uintptr等。 </li><li>浮点类型:float32、float64。</li><li>复数类型:complex64、complex128。 </li><li>字符串:string。</li><li>字符类型:rune。</li><li>错误类型:error。</li></ul><p>此外，Go语言也支持以下这些复合类型: </p><ul><li>指针(pointer)</li><li>数组(array)</li><li>切片(slice)</li><li>字典(map)</li><li>通道(chan)</li><li>结构体(struct) </li><li>接口(interface)</li></ul><p>需要注意的是int和int32在Go语言里被认为是两种不同的类型，编译器也不会帮你自动做类型转换，使用强制类型转换可以解决。当然，开发者在做强制类型转换时，需要注意数据长度被截短而发生的数据精度损失(比如将浮点数强制转为整数)和值溢出(值超过转换的目标类型的值范围时)问题。而且，两个不同类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较。</p><h4 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h4><p>因为浮点数不是一种精确的表达方式，所以像整型那样直接用==来判断两个浮点数是否相等 是不可行的，这可能会导致不稳定的结果。下面是一种推荐的替代方案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;math&quot;</span><br><span class="line">// p为用户自定义的比较精度，比如0.00001 </span><br><span class="line">func IsEqual(f1, f2, p float64) bool &#123;</span><br><span class="line">return math.Fdim(f1, f2) &lt; p </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个复数z = complex(x, y)，就可以通过Go语言内置函数real(z)获得该复数的实 部，也就是x，通过imag(z)获得该复数的虚部，也就是y。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>golang字符串使用方式和python类似。但是，字符串的内容不能在初始化后被修改。</p><p>字符串遍历方式有两种。一种是以字节数组的方式遍历:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str := &quot;Hello,世界&quot;</span><br><span class="line">n := len(str)</span><br><span class="line">for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        ch := str[i] // 依据下标取字符串中的字符，类型为byte</span><br><span class="line">        fmt.Println(i, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 72</span><br><span class="line">1 101</span><br><span class="line">2 108</span><br><span class="line">3 108</span><br><span class="line">4 111</span><br><span class="line">5 44</span><br><span class="line">6 32</span><br><span class="line">7 228</span><br><span class="line">8 184</span><br><span class="line">9 150</span><br><span class="line">10 231</span><br><span class="line">11 149</span><br><span class="line">12 140</span><br></pre></td></tr></table></figure><p>可以看出，这个字符串长度为13。尽管从直观上来说，这个字符串应该只有9个字符。这是 因为每个中文字符在UTF-8中占3个字节，而不是1个字节。<br>另一种是以Unicode字符遍历:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := &quot;Hello,世界&quot;</span><br><span class="line">for i, ch := range str &#123;</span><br><span class="line">fmt.Println(i, ch)//ch的类型为rune &#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 72</span><br><span class="line">1 101</span><br><span class="line">2 108</span><br><span class="line">3 108</span><br><span class="line">4 111</span><br><span class="line">5 44</span><br><span class="line">6 32</span><br><span class="line">7 19990</span><br><span class="line">10 30028</span><br></pre></td></tr></table></figure><p>以Unicode字符方式遍历时，每个字符的类型是rune(早期的Go语言用int类型表示Unicode 字符)，而不是byte。在Go语言中支持两个字符类型，一个是byte(实际上是uint8的别名)，代表UTF-8字符串的单个字节的值;另一个是rune，代表单个Unicode字符。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>以下为一些常规的数组声明方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[32]byte // 长度为32的数组，每个元素为一个字节 </span><br><span class="line">[2*N] struct &#123; x, y int32 &#125; // 复杂类型数组</span><br><span class="line">[1000]*float64  // 指针数组</span><br><span class="line">[3][5]int // 二维数组</span><br><span class="line">[2][2][2]float64 // 等同于[2]([2]([2]float64))</span><br></pre></td></tr></table></figure><p>从以上类型也可以看出，数组可以是多维的，比如[3][5]int就表达了一个3行5列的二维整 型数组，总共可以存放15个整型元素。<br>在Go语言中，数组长度在定义后就不可更改，在声明时长度可以为一个常量或者一个常量 表达式(常量表达式是指在编译期即可计算结果的表达式)。</p><p>Go语言提供了一个关键字range，用于便捷地遍历容器中的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i, v := range array &#123;</span><br><span class="line">fmt.Println(&quot;Array element[&quot;, i, &quot;]=&quot;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意的是，在Go语言中数组是一个值类型(value type)。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该 参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所 传入数组的一个副本。(和python不同)</p><p>关于数组切片，和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该 参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所 传入数组的一个副本。使用数组切片的方式和python类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 先定义一个数组</span><br><span class="line">var myArray [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; </span><br><span class="line">// 基于数组创建一个数组切片</span><br><span class="line">var mySlice []int = myArray[:5]</span><br></pre></td></tr></table></figure><p>Go语言提供的内置函数make()可以用于灵活地创建数组切片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mySlice1 := make([]int, 5)</span><br><span class="line">mySlice3 := []int&#123;1, 2, 3, 4, 5&#125;</span><br></pre></td></tr></table></figure><p>数组切片支持Go语言内置的cap()函数和len()函数，cap()函数返回的是数组切片分配的空间大小，而len()函数返回的是 数组切片中当前所存储的元素个数。</p><p>使用append()函数给数组切片添加元素,函数append()的第二个参数其实是一个不定参数，我们可以按自己需求添加若干个元素，甚至直接将一个数组切片追加到另一个数组切片的末尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mySlice = append(mySlice, 1, 2, 3)</span><br><span class="line">mySlice2 := []int&#123;8, 9, 10&#125;</span><br><span class="line">// 给mySlice后面添加另一个数组切片</span><br><span class="line">mySlice = append(mySlice, mySlice2...)</span><br></pre></td></tr></table></figure><p>数组切片支持Go语言的另一个内置函数copy()，用于将内容从一个数组切片复制到另一个 数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行 复制。</p><h4 id="map基本用法"><a href="#map基本用法" class="headerlink" title="map基本用法"></a>map基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">personDB = make(map[string] PersonInfo)</span><br><span class="line">// 往这个map里插入几条数据</span><br><span class="line">personDB[&quot;12345&quot;] = PersonInfo&#123;&quot;12345&quot;, &quot;Tom&quot;, &quot;Room203,...&quot;&#125; personDB[&quot;1&quot;] = PersonInfo&#123;&quot;1&quot;, &quot;Jack&quot;, &quot;Room 101,...&quot;&#125;</span><br><span class="line">// 从这个map查找键为&quot;1234&quot;的信息 </span><br><span class="line">person, ok := personDB[&quot;1234&quot;]</span><br><span class="line">// ok是一个返回的bool型，返回true表示找到了对应的数据 </span><br><span class="line">if ok &#123;</span><br><span class="line">fmt.Println(&quot;Found person&quot;, person.Name, &quot;with ID 1234.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;Did not find person with ID 1234.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map的声明基本上没有多余的元素，比如:<code>var myMap map[string] PersonInfo</code> myMap是声明的map变量名，string是键的类型，PersonInfo则是其中所存放的值类型.我们可以使用Go语言内置的函数make()来创建一个新map。下面的这个例子创建了一个键 类型为string、值类型为PersonInfo的map:<br><code>myMap = make(map[string] PersonInfo)</code></p><p>Go语言提供了一个内置函数delete()，用于删除容器内的元素<code>delete(myMap, &quot;1234&quot;)</code>如果“1234”这个键不存在，那么这个调用将什么都不发生，也不会有什么副作用。但是如果传入的map变量的值是nil，该调用将导致 程序抛出异常(panic)</p><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><p>go语言的条件控制语句，需要注意以下几点：</p><ul><li>条件语句不需要使用括号将条件包含起来();</li><li>无论语句体内有几条语句，花括号{}都是必须存在的;</li><li>左花括号{必须与if或者else处于同一行;</li><li>在if之后，条件语句之前，可以添加变量初始化语句，使用;间隔;</li><li>在有返回值的函数中，不允许将“最终的”return语句包含在if…else…结构中，否则会编译失败</li></ul><p>而switch结构需要注意：</p><ul><li>左花括号{必须与switch处于同一行;</li><li>条件表达式不限制为常量或者整数;</li><li>单个case中，可以出现多个结果选项;</li><li>与C语言等规则相反，Go语言不需要用break来明确退出一个case;</li><li>只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case; 可以不设定switch之后的条件表达式，在此种情况下，整个switch结构与多个if…else…的逻辑作用等同。</li></ul><p>Go语言的for循环同样支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环，如下例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for j := 0; j &lt; 5; j++ &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">if i &gt; 5 &#123; break JLoop</span><br><span class="line">               &#125;</span><br><span class="line">           fmt.Println(i)</span><br><span class="line">&#125; &#125;</span><br><span class="line">JLoop:</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package mymath import &quot;errors&quot;</span><br><span class="line">func Add(a int, b int) (ret int, err error) &#123;</span><br><span class="line">if a &lt; 0 || b &lt; 0 &#123; // 假设这个函数只支持两个非负数字的加法</span><br><span class="line">        err= errors.New(&quot;Should be non-negative numbers!&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">return a + b, nil // 支持多重返回值 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数列表中若干个相邻的参数类型的相同，比如上面例子中的a和b，则可以在参数列表 中省略前面变量的类型声明.如果返回值列表中多个返回值的类型相同，也可以用同样的方式合并</p><h3 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(args ...int) &#123;</span><br><span class="line">for _, arg := range args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形如…type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。它是一 个语法糖(syntactic sugar)，即这种语法对语言的功能并没有影响，但是更方便程序员使用。通 常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的机会。</p><p>从内部实现机理上来说，类型…type本质上是一个数组切片，也就是[]type，这也是为 什么上面的参数args可以用for循环来获得每个传入的参数。</p><p>不定参数可以原样传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(args ...int) &#123; // 按原样传递</span><br><span class="line">        myfunc3(args...)</span><br><span class="line">// 传递片段，实际上任意的int slice都可以传进去</span><br><span class="line">        myfunc3(args[1:]...)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之前的例子中将不定参数类型约束为int，如果你希望传任意类型，可以指定类型为 interface{}。下面是Go语言标准库中fmt.Printf()的函数原型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Printf(format string, args ...interface&#123;&#125;) &#123; </span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>golang中的匿名函数可以直接赋值给一个变量或者直接执行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f := func(x, y int) int &#123; </span><br><span class="line">return x + y</span><br><span class="line">&#125;</span><br><span class="line">func(ch chan int) &#123; </span><br><span class="line">ch &lt;- ACK</span><br><span class="line">&#125; (reply_chan) // 花括号后直接跟参数列表表示函数调用</span><br></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go语言引入了一个关于错误处理的标准模式，即error接口，该接口的定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123; </span><br><span class="line">Error() string</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>下面用Go库中的实际代码来示范如何使用自定义的error类型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type PathError struct &#123; </span><br><span class="line">Op string</span><br><span class="line">Path string</span><br><span class="line">Err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *PathError) Error() string &#123;</span><br><span class="line">return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go语言使用defer关键字，一个函数中可以存在多个defer语句，因此需要注意的是，defer语句的调用是遵照先进后出的原则，即最后一个defer语句将最先被执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dst, src string) (w int64, err error) &#123; srcFile, err := os.Open(src)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer srcFile.Close()</span><br><span class="line">dstFile, err := os.Create(dstName) </span><br><span class="line">if err != nil &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">defer dstFile.Close()</span><br><span class="line">return io.Copy(dstFile, srcFile) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使其中的Copy()函数抛出异常，Go仍然会保证dstFile和srcFile会被正常关闭。</p><p>Go语言引入了两个内置函数panic()和recover()以报告和处理运行时错误和程序中的错误场景:</p><p>当在一个函数执行过程中调用panic()函数时，正常的函数执行流程将立即终止，但函数中 之前使用defer关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致 逐层向上执行panic流程，直至所属的goroutine中所有正在执行的函数被终止。错误信息将被报 告，包括在调用panic()函数时传入的参数，这个过程称为错误处理流程。</p><p>recover()函数用于终止错误处理流程。一般情况下，recover()应该在一个使用defer 关键字的函数中执行以有效截取错误处理流程。如果没有在发生异常的goroutine中明确调用恢复 过程(使用recover关键字)，会导致该goroutine所属的进程打印异常信息后直接退出。</p><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Go语言并没有沿 袭传统面向对象编程中的诸多概念，比如继承、虚函数、构造函数和析构函数、隐藏的this指针等。同时，Go语言对面向对象编程的支持是语言类型系统中的天然组成部分。整个类型系统通过接口串联，浑然一体。</p><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>在看go的类型系统前，先看看java的类型系统：</p><p>在Java语言中，存在两套完全独立的类型系统:一套是值类型系统，主要是基本类型，如byte、 int、boolean、char、double等，这些类型基于值语义;一套是以Object类型为根的对象类型 系统，这些类型可以定义成员变量和成员方法，可以有虚函数，基于引用语义，只允许在堆上创建(通过使用关键字new)。</p><p>Java语言中的Any类型就是整个对象类型系统的根——java.lang.Object 类型，只有对象类型系统中的实例才可以被Any类型引用。值类型想要被Any类型引用，需要装箱 (boxing)过程，比如int类型需要装箱成为Integer类型。另外，只有对象类型系统中的类型才可以实现接口，具体方法是让该类型从要实现的接口继承。</p><p>相比之下，Go语言中的大多数类型都是值语义，并且都可以包含对应的操作方法。在需要的时候，你可以给任何类型(包括内置类型)“增加”新方法。而在实现某个接口时，无需从 该接口继承(事实上，Go语言根本就不支持面向对象思想中的继承语法)，只需要实现该接口 要求的所有方法即可。任何类型都可以被Any类型引用。Any类型就是空接口，即interface{}。</p><p>例如，我们定义了一个新类型Integer，它和int没有本质不同，只是它为内置的int类型增加了个新方法Less()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Integer int</span><br><span class="line">func (a Integer) Less(b Integer) bool &#123; </span><br><span class="line">return a &lt; b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值语义和引用语义的差别在于赋值，比如下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b=a </span><br><span class="line">b.Modify()</span><br></pre></td></tr></table></figure><p>如果b的修改不会影响a的值，那么此类型属于值类型。如果会影响a的值，那么此类型是引用类型。Go语言中的大多数类型都基于值语义, 包括数组（和python的list不一样）.Go语言中的数组和基本类型没有区别，是很纯粹的值类型</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言的结构体(struct)和其他语言的类(class)有同等的地位，但Go语言放弃了包括继 承在内的大量面向对象特性，只保留了组合(composition)这个最基础的特性。</p><p>下面代码展示了如何定义并初始化一个类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Rect struct &#123; </span><br><span class="line">x, y float64</span><br><span class="line">width, height float64 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *Rect) Area() float64 &#123; </span><br><span class="line">return r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rect1 := new(Rect)</span><br><span class="line">rect2 := &amp;Rect&#123;&#125;</span><br><span class="line">rect3 := &amp;Rect&#123;0, 0, 100, 200&#125;</span><br><span class="line">rect4 := &amp;Rect&#123;width: 100, height: 200&#125;</span><br></pre></td></tr></table></figure><p>在Go语言中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以 NewXXX来命名，表示“构造函数”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func NewRect(x, y, width, height float64) *Rect &#123; </span><br><span class="line">return &amp;Rect&#123;x, y, width, height&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名组合（继承？）"><a href="#匿名组合（继承？）" class="headerlink" title="匿名组合（继承？）"></a>匿名组合（继承？）</h3><p>确切地说，Go语言也提供了继承，但是采用了组合的文法，所以我们将其称为匿名组合:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Base struct &#123; </span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line">func (base *Base) Foo() &#123; ... &#125;</span><br><span class="line">func (base *Base) Bar() &#123; ... &#125;</span><br><span class="line">type Foo struct &#123; </span><br><span class="line">Base</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">func (foo *Foo) Bar() &#123;</span><br><span class="line">foo.Base.Bar()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码定义了一个Base类(实现了Foo()和Bar()两个成员方法)，然后定义了一个 Foo类，该类从Base类“继承”并改写了Bar()方法(该方法实现时先调用了基类的Bar() 方法)。</p><p>在“派生类”Foo没有改写“基类”Base的成员方法时，相应的方法就被“继承”，例如在 上面的例子中，调用foo.Foo()和调用foo.Base.Foo()效果一致。</p><p>另外，在Go语言中，你还可以以指针方式从一个类型“派生”:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Foo struct &#123;</span><br><span class="line">*Base</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段Go代码仍然有“派生”的效果，只是Foo创建实例的时候，需要外部提供一个Base类 实例的指针。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>Go语言对关键字的增加非常吝啬，其中没有private、protected、public这样的关键字。要使某个符号对其他包(package)可见(即可以访问)，需要将该符号定义为以大写字母开头</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口在Go语言有着至关重要的地位。如果说goroutine和channel是支撑起Go语言的并发模型的基石，让Go语言在如今集群化与多核化的时代成为一道极为亮丽的风景，那么接口是Go语言整个类型系统的基石，让Go语言在基础编程哲学的探索上达到前所未有的高度。</p><p>go语言使用非侵入式接口，即类并没有从这些接口继承，甚至可以不知道这些接口的存在，但是Fi类实现了这些接口，可以进行赋值。Go语言的非侵入式接口，看似只是做了很小的文法调整，实则影响深远。</p><ul><li>其一，Go语言的标准库，再也不需要绘制类库的继承树图。你一定见过不少C++、Java、C# 类库的继承树图</li><li>其二，实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才 合理。接口由使用方按需定义，而不用事前规划</li><li>其三，不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦 合</li></ul><h5 id="接口查询"><a href="#接口查询" class="headerlink" title="接口查询"></a>接口查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var file1 Writer = ...</span><br><span class="line">if file5, ok := file1.(two.IStream); ok &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if语句检查file1接口指向的对象实例是否实现了two.IStream接口，如果实现了，则执 行特定的代码。接口查询是否成功，要在运行期才能够确定。它不像接口赋值，编译器只需要通过静态类型 检查即可判断赋值是否可行。</p><p>在Go语言中，还可以更加直截了当地询问接口指向的对象实例的类型，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var v1 interface&#123;&#125; = ... </span><br><span class="line">switch v := v1.(type) &#123;</span><br><span class="line">case int: // 现在v的类型是int </span><br><span class="line">case string: // 现在v的类型是string</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h5><p>由于Go语言中任何对象实例都满足空接口interface{}，所以interface{}看起来像是可以指向任何对象的Any类型，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var v1 interface&#123;&#125; = 1</span><br><span class="line">var v2 interface&#123;&#125; = &quot;abc&quot;</span><br><span class="line">var v3 interface&#123;&#125; = &amp;v2</span><br><span class="line">var v4 interface&#123;&#125; = struct&#123; X int &#125;&#123;1&#125;</span><br><span class="line">var v5 interface&#123;&#125; = &amp;struct&#123; X int &#125;&#123;1&#125;</span><br></pre></td></tr></table></figure><p>当函数可以接受任意的对象实例时，我们会将其声明为interface{}，最典型的例子是标 准库fmt中PrintXXX系列的函数</p><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>BDD行为驱动开发概要</title>
      <link href="/bdd_profile.html"/>
      <url>/bdd_profile.html</url>
      <content type="html"><![CDATA[<h1 id="BDD和TDD"><a href="#BDD和TDD" class="headerlink" title="BDD和TDD"></a>BDD和TDD</h1><p>行为驱动开发（Behavior-Driven Development, 简称BDD）,是在测试驱动开发(Test-Driven Development, TDD)基础上发展而来的一种软件开发方法。TDD最大的弊端，是面对一大堆功能需求和用例时，往往会感到无从下手。另一方面，由于TDD更侧重于测试本身，因此容易忽视对业务需求的表达，最终沉溺于琐碎细节而无法自拔。</p><p>与传统的软件开发方法相比，BDD的本质在于尽可能避免在需求描述、用例撰写、代码实现、测试等各环节衔接、转译过程中发生的信息丢失。为此，BDD以用例Use Case和示例Example为核心，借助Gherkin等一些特有概念和一系列BDD特有工具，以更贴近业务场景的方式，实现软件需求的完整实现。</p><p>BDD 使用几乎近于自然语言的方式描述了软件的行为过程，因此，可以直接作为软件的需求文档，也可以直接应用到测试中，作为测试的标准文档。BDD描述的行为就像一个个的故事(Story)，系统业务专家、开发者、测试人员一起合作，分析软件的需求，然后将这些需求写成一个个的故事。开发者负责填充这些故事的内容，测试者负责检验这些故事的结果。通常，会使用一个故事的模板来对故事进行描述</p><p>常见的BDD框架有ruby的cucumber，python的behave，java的JBehave等等，本文使用python的behave举例。</p><h1 id="初识behave"><a href="#初识behave" class="headerlink" title="初识behave"></a>初识behave</h1><p>###安装</p><blockquote><p>pip install behave #安装<br>pip install -U behave # 更新</p></blockquote><p>###Gherkin语法<br>Gherkin是一种简单易懂的语言，使用关键字来定义系统特征和测试，支持中文, 使用Gherkin语法编写的feature文件基本结构大体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Feature:Title</span><br><span class="line">    Background:</span><br><span class="line">      Given 给出全局背景条件</span><br><span class="line"> </span><br><span class="line">    Scenario: Title1 (行为1)</span><br><span class="line"> </span><br><span class="line">        Given  [给出相关设置]</span><br><span class="line">        When  [当某事件发生时]</span><br><span class="line">        Then  [期望发生什么样的结果]</span><br><span class="line"> </span><br><span class="line">    Scenario: Title2 (行为2)......</span><br></pre></td></tr></table></figure><p>###实际示例<br>首先在test目录下新建test.py, 我们实现了快速排序quick_sort方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def quick_sort(array):</span><br><span class="line">if len(array) &lt; 2:</span><br><span class="line">return array</span><br><span class="line">else:</span><br><span class="line">first = array[0]</span><br><span class="line">left = quick_sort([x for x in array[1:] if x &lt; first])</span><br><span class="line">right = quick_sort([x for x in array[1:] if x &gt;= first])</span><br><span class="line">return left + [first] + right</span><br></pre></td></tr></table></figure><p>接下来我们将使用behave来测试快速排序，在test目录新建features目录，在futures目录下新建steps/sort_steps.py，environment.py，sort.feature三个文件，新建完成后的test目录如下:</p><p>编辑sort.feature</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Feature: 快排</span><br><span class="line"> </span><br><span class="line">    Scenario: 快速排序测试</span><br><span class="line"> </span><br><span class="line">        Given  we have the list</span><br><span class="line">        &quot;&quot;&quot;[1, 3, 6, 8, 2, 5, 6, 1, 4]&quot;&quot;&quot;</span><br><span class="line">        When  调用quick_sort方法</span><br><span class="line">        Then  返回的结果与预期的一致</span><br><span class="line">        &quot;&quot;&quot;[1, 1, 2, 3, 4, 5, 6, 6, 8]&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>编辑sort_steps.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import json</span><br><span class="line">from behave import *</span><br><span class="line">import test</span><br><span class="line"></span><br><span class="line">@given(&quot;we have the list&quot;)</span><br><span class="line">def step_impl(context):</span><br><span class="line">data = json.loads(context.text)</span><br><span class="line">    context.listdata = data</span><br><span class="line"></span><br><span class="line">@when(u&quot;调用&#123;function&#125;方法&quot;)</span><br><span class="line">def step_impl(context, function):</span><br><span class="line">    result = getattr(test, function)(context.listdata)</span><br><span class="line">    context.result = result</span><br><span class="line"></span><br><span class="line">@then(u&quot;返回的结果与预期的一致&quot;)</span><br><span class="line">def step_impl(context):</span><br><span class="line">    assert josn.loads(context.text) == context.result</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker核心原理</title>
      <link href="/docker_core_principles.html"/>
      <url>/docker_core_principles.html</url>
      <content type="html"><![CDATA[<h1 id="docker-原理综述"><a href="#docker-原理综述" class="headerlink" title="docker 原理综述"></a>docker 原理综述</h1><p>docker相比于虚拟机，在资源利用上的效率比虚拟机高出很多，另外docker的启动速度也是虚拟机不能比的，那么docker是如何实现这些的呢。首先docker基于Linux，通过Linux的namespace实现了资源隔离，通过cgroups实现了资源限制，通过写时复制机制（copy-on-write）技术实现了高效的文件操作。</p><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>namespace隔离，docker使用了六种隔离方式,分别为UTS(主机名和域名)，IPC(信号量，消息队列和共享内存)，PID(进程编号)，Network(网络设备，网络栈，端口等),Mount(挂载点),User(用户和用户组)。Linux内核实现namespace的主要目的之一就是实现轻量级虚拟化服务。在同一个namespace下的进程可以感知彼此的变化，而对外界的进程一无所知，以达到独立和隔离的目的。</p><p>Linux中namespaceAPI操作有</p><ul><li>clone接口（创建新进程的同时创建namespace）</li><li>setns()接口（加入一个已经存在的namespace, docker的exec命令在已经运行的容器中执行一个新的命令就需要用到该方法）</li><li>unshare方法（使当前进程退出指定类型的namespace，并加入到新创建的namespace（相当于创建并加入新的namespace），与clone的不同之处在于，unshare运行在原先的进程上，不需要启动一个新的进程）</li></ul><p>可以通过查看/proc/[pid]/nc文件来查看进程所属的namespace。另外说一下Linux中的fork，调用fork时候，系统创建新的进程，为其分配资源，把原来进程中的值都复制到新进程中，只有少量值与原来不同，fork的神奇之处在于，他只被调用了一次，却能够返回两次数值（父进程返回子进程id，子进程返回0，出错返回负值）</p><h3 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h3><p>cgroups可以限制、记录任务组所使用的物理资源（包括CPU，memory，IO等），为容器实现虚拟化提供了基本保证，是构建Docker等一系列虚拟化管理工具的基石。</p><p>cgroups作用包括：</p><ol><li>资源限制</li><li>优先级分配</li><li>资源统计</li><li>任务控制</li></ol><p>cgroups包含：</p><ol><li>tasks任务：表示一个系统的进程或线程</li><li>cgroup控制组：表示某种资源按照控制标准划分而成的任务组，包含一个或多个子系统，任务可加入某个cgroup，也可以从某个cgroup迁移到另外一个cgroup</li><li>subsystem（子系统）：子系统是一个资源调度控制器。（例如CPU子系统）</li><li>hierarchy（层级）：由一系列cgroup以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。每个节点可以包含0个或多个子节点，子节点继承父节点挂载的子系统。整个操作系统可以有多个层级。</li></ol><h1 id="docker架构概览"><a href="#docker架构概览" class="headerlink" title="docker架构概览"></a>docker架构概览</h1><ul><li>docker daemon 是docker最核心的后台进程，负责响应docker client请求，然后将请求翻译成系统调用完成容器管理工作。<ul><li>其中容器管理驱动execdriver是daemon的一个重要组成部分，它封装了namespace，cgroup，等对os资源进行操作的所有方法，在docker中，其默认实现就是libcontainer。libcontainer本身主要分为三大块内容，一是容器的创建及初始化，二是容器生命周期管理，三是进程管理，由docker的execdriver来调用。</li></ul></li><li>docker client 是一个泛称，用来向docker daemon发起请求，执行响应容器管理的操作</li><li>graph组件负责维护已下载的镜像信息及他们之间的关系。</li><li>graphdb记录它所维护的所有容器以及他们之间的link关系，所以采用了一个图结构来保存这些数据。（基于sqlite实现）</li><li>driver 是为了将系统调用抽象成为统一的操作接口，方便调用者使用，docker将这些操作分类成容器管理驱动(execdriver)、网络管理驱动(networkdriver)、文件存储驱动(graphdriver)三种。</li></ul><h1 id="docker镜像管理："><a href="#docker镜像管理：" class="headerlink" title="docker镜像管理："></a>docker镜像管理：</h1><p>docker镜像采用分层的结构构建，最底层是bootfs，之上的部分是rootfs。bootfs是docker镜像最底层的引导文件系统，包括bootloader和操作系统内核。rootfs位于bootfs之上，是docker容器在启动时内部进程可见的文件系统，即docker容器的根目录。</p><p>在传统的Linux操作系统的内核启动时，首先挂载一个只读的rootfs，当系统检测其完整性之后，再将其切换为读写模式。而在docker架构中，当docker daemon为docker容器挂载rootfs时，沿用Linux内核启动的方法，即将rootfs设为只读模式。在挂载完毕之后，利用联合挂载技术（union mount）在已有的只读rootfs上再挂载一个读写层，只有在docker容器运行过程中文件系统发生变化时，才会把变化的内容写到可读写层，并隐藏只读层中的老版本文件，这样的技术被称为写时复制。</p><p>docker 镜像管理关键概念:</p><ul><li>registry: 用以保存docker镜像，其中还包括镜像层次结构和关于镜像的元数据</li><li>repository: 由具有某个功能的docker镜像的所有迭代版本构成的镜像库，即registry是repository的集合，repository是镜像的集合</li><li>index: 类似于registry的索引，复制搜索镜像，打标签等服务</li><li>graph: 负责保存从registry中下载的docker镜像</li><li>dockerfile: 通过dockerbuild命令构建自己的docker镜像时，需要使用到的定义文件</li></ul><h1 id="docker-数据卷volum"><a href="#docker-数据卷volum" class="headerlink" title="docker 数据卷volum"></a>docker 数据卷volum</h1><pre><code>添加volume类似于Linux的mount操作，用户将一个文件夹作为volume挂载在容器上，可以方便的将数据添加到容器中供其中的进程使用。多个容器可以共享同一个volume，为了不同的容器之间的数据共享提供了便利。</code></pre>]]></content>
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker常用命令</title>
      <link href="/docker_common_commands.html"/>
      <url>/docker_common_commands.html</url>
      <content type="html"><![CDATA[<h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><p>Docker就是，以docker容器为资源分割和调度的基本单位，封装整个软件运行时环境，为开发者和系统管理员设计的，用于构建、发布和运行分布式应用的平台。</p><p>docker的特性是易用，跨平台，可移植性。优势在于简化CI（持续集成）和CD（持续交互）的构建流程，让开发者集中精力在应用开发上。docker命令繁杂，本篇记录了docker常用的命令。</p><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><ol><li>docker 环境信息<ul><li>docker info用于检查docker是否正确安装，一般结合docker version使用</li></ul></li><li><p>容器生命周期管理,涉及容器启动，停止等功能，常用的有run，start,stop,restart</p><ul><li><p>docker run命令用于基于特定的镜像创建一个容器，并依据选项控制容器。</p><ul><li>-i选项表示使用交互模式，始终保持输入流开放</li><li>-t选项表示分配一个伪终端，一般两个参数结合使用-it, 即可在终端中打开伪终端进行交互操作</li><li>–name选项可指定docker run命令启动的容器的名字。否则，docker将为容器随机分配一个名字</li><li>-c选项用于给运行在容器中的所有进程分配cpu的share值，这是一个相对权重，实际的处理速度还是与宿主机的cpu有关</li><li>-m选项 用于限制为容器中所有进程分配的内存总量，以B,K,M,G为单位</li><li>-v选项 用于挂载一个volume， 可以用一个-v参数挂载多个volume volume的格式为[host-dir]:[container-dir]:<a href="即宿主机文件/目录:容器里对应的文件/目录，rw为可读写，ro为只可读">rw:ro</a></li><li>-p选项用于将容器的端口暴露给宿主机的端口，其常用格式为hostPort:containerPort</li><li>-e或者-env设置环境变量</li><li>–link [name:aliasname]连接名为name的容器，并起一个别名为aliasname, 使用link不仅可以避免ip和端口暴露在外网的风险，还可以预防容器在重启后ip地址变化导致的访问失败，原理类似于dns的域名和地址映射。</li></ul></li><li><p>docker start/stop/restart命令用于对已存在的容器进去启动，停止和重启，一般使用容器id作标识，也可使用容器名来确定容器.start命令使用-i选项来开启交互模式，始终保持输入流开放。使用-a附加标准输入、输出和错误输出。此外，docker stop和docker restart命令使用-t选项来设定容器停止前的等待时间。</p></li></ul></li><li>docker registry<ul><li>docker pull命令从registry中拉取image或repository，使用方法为docker pull [options] name[:tag]，例如docker pull SEL/ubuntu:ubuntu12.04为从特定仓库拉取Ubuntu 12.04 tag的镜像</li><li>docker push命令将本地image或者repository推送到镜像库，使用方法如下: docker push NAME[:TAG]</li><li>docker commit 将一个容器固化为一个新的镜像，提交时只能选用正在运行的容器。</li></ul></li><li>镜像管理<ul><li>docker images列出主机镜像，默认只有顶层镜像，可以使用-a显示所有镜像</li><li>docker rmi删除镜像，可同时删除多个，但是删除镜像前必须先删除容器</li><li>docker rm删除容器,可同时删除多个</li><li>docker build构建镜像，-t指定最终镜像名称，后指定上下文路径，或Git repo或tar或从标准输入中读取</li></ul></li><li>运维操作<ul><li>docker attach连接到正在运行的容器，与主进程进行交互</li><li>docker inspect可以查看容器或镜像的详细信息</li><li>docker ps命令查看容器相关信息，默认只显示正在运行的容器,-a参数可以查看所有容器，-l参数可以查看最新的容器</li><li>docker events打印实时系统事件</li><li>docker history打印指定镜像历史版本信息</li><li>docker logs打印容器中进程的运行日志</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>fabric 服务器管理和应用发布神器</title>
      <link href="/about_fabric.html"/>
      <url>/about_fabric.html</url>
      <content type="html"><![CDATA[<h1 id="Fabric简介"><a href="#Fabric简介" class="headerlink" title="Fabric简介"></a>Fabric简介</h1><p>Fabric是一个Python的库和命令行工具,使用 Fabric 来执行 Python 函数或 task ，以实现与远程服务器的自动化交互, 提高基于ssh的应用部署和系统管理效率。</p><p>具体来说：</p><ul><li>可以通过命令行执行无参数python函数的工具</li><li>可以通过ssh更容易，更符合python风格的执行shell命令</li></ul><h1 id="STEP1-hello-wrold"><a href="#STEP1-hello-wrold" class="headerlink" title="STEP1: hello wrold"></a>STEP1: hello wrold</h1><p>使用pip安装fabric包，将以下代码写入fabfile.py文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def  hello （）：</span><br><span class="line">    print （“Hello world！” ）</span><br></pre></td></tr></table></figure><p>然后该hello函数即可作为fab工具，使用命令<code>fab hello</code>即可在命令行中打印出<code>hello world！</code></p><p>另外，和Python编程一样，给任务函数传递参数很有必要.Fabric支持Shell兼容的参数用法，让我们把代码改写一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def  hello (name = &quot;world&quot;):</span><br><span class="line">    print(&quot;Hello %s!&quot; % name)</span><br></pre></td></tr></table></figure><p>运行<code>fab hello:fabric</code>即可传入name=fabric参数，打印出<code>hello fabric！</code></p><h1 id="STEP2-运行本地和远程命令"><a href="#STEP2-运行本地和远程命令" class="headerlink" title="STEP2: 运行本地和远程命令"></a>STEP2: 运行本地和远程命令</h1><p>fabric使用local和run分别运行本地和远程命令，使用lcd和cd分别进行本地和远程的目录跳转。假设我们目前有一个django项目，我们希望进行如下自动化部署操作：</p><ul><li>运行<code>test my_app</code>进行自动化测试</li><li>使用git上传代码</li><li>在远程服务器更新代码</li></ul><p>我们将该操作分为两步，一步使用prepare_deploy进行本地代码的测试和上传，一步使用deploy进行远程代码的发布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from fabric.api import local, settings, abort, run, cd, lcd</span><br><span class="line"></span><br><span class="line">def prepare_deploy():</span><br><span class="line">    code_dir = &apos;/srv/django/myproject&apos;</span><br><span class="line">    with lcd(code_dir):</span><br><span class="line">        local(&quot;./manage.py test my_app&quot;)</span><br><span class="line">        local(&quot;git add -p &amp;&amp; git commit&quot;)</span><br><span class="line">        local(&quot;git push&quot;)</span><br><span class="line"></span><br><span class="line">def deploy():</span><br><span class="line">    code_dir = &apos;/srv/django/myproject&apos;</span><br><span class="line">    with settings(warn_only=True):</span><br><span class="line">        if run(&quot;test -d %s&quot; % code_dir).failed:</span><br><span class="line">            run(&quot;git clone user@vcshost:/path/to/repo/.git %s&quot; % code_dir)</span><br><span class="line">    with cd(code_dir):</span><br><span class="line">        run(&quot;git pull&quot;)</span><br></pre></td></tr></table></figure><p>在deploy函数中，我们首先判断对应文件夹是否存在，不存在我们就将拉取代码。我们使用<code>with settings(warn_only=True)</code>将warn_only设置为true，该设置将代码中的error认为是警告来处理，以达到代码的灵活性。</p><p>将上述代码中的14行项目git库修改后，即可运行命令来完成操作，在运行<code>fab deploy</code>后需要输入连接远程的host string（如<a href="mailto:&#39;root@192.168.1.200" target="_blank" rel="noopener">&#39;root@192.168.1.200</a>‘），如果你的电脑与远程机器已经设置好ssh秘钥，则会直接连接成功，运行命令，否则需要输入密码。</p><p>运行结果如下:</p><p><img src="/images/fabric/ssh.png" alt="" title="描述"></p><h1 id="STEP3-其他有用配置"><a href="#STEP3-其他有用配置" class="headerlink" title="STEP3: 其他有用配置"></a>STEP3: 其他有用配置</h1><h3 id="环境字典env"><a href="#环境字典env" class="headerlink" title="环境字典env"></a>环境字典env</h3><p>如果我们有很多台服务器做负载均衡，我们不可能每台服务器都运行一次deploy，这时我们需要用到fabric的环境字典env</p><p>env下常用字典有user，roledefs和password字段，user字段用于设置连接远程的默认用户名，roledefs字段用于这时远程主机集群，passwords字段用于存储远程主机密码（如果你不想用ssh秘钥连接的话）。我们在fabric开头加入如下配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from fabric.api import local, settings, abort, run, cd, lcd， env</span><br><span class="line"></span><br><span class="line">env.user = &apos;root&apos;</span><br><span class="line"></span><br><span class="line">env.roledefs.update(&#123;</span><br><span class="line">&apos;test&apos;: [&apos;192.168.150.90&apos;],</span><br><span class="line">&apos;deploy&apos;: [</span><br><span class="line">&apos;192.168.141.113&apos;,</span><br><span class="line">&apos;192.168.133.102&apos;,</span><br><span class="line">&apos;192.168.129.150&apos;,</span><br><span class="line">&apos;192.168.100.199&apos;,</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">env.passwords = &#123;</span><br><span class="line">&apos;root@192.168.150.90:22&apos;: &quot;root&quot;,</span><br><span class="line">&apos;root@192.168.141.113:22&apos;: &apos;root&apos;,</span><br><span class="line">&apos;root@192.168.133.102:22&apos;: &apos;root&apos;,</span><br><span class="line">&apos;root@192.168.129.150:22&apos;: &apos;root&apos;,</span><br><span class="line">&apos;root@192.168.100.199:22&apos;: &quot;root&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们配置了两个集群，分别为test测试服服务器和deploy正式服集群，配置登录用户名为root以及登录密码。</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>fabric中提供了方便我们使用的装饰器，在配置完上述env后，我们可以为deploy加上role装饰器来制定对应集群.</p><p>对于一些可以并行执行的函数我们可以使用同时parallel装饰器来并行执行，或者对于一些不能并行执行的函数我们使用serial装饰器强制顺序执行（fabric默认顺序执行，如果修改 env.parallel可设置为并行执行，但是serial和parallel优先级更高）。</p><p>最后，我们可以使用task装饰器来装饰我们需要独立成任务的函数，使用task装饰器后，运行<code>fab --list</code>只有被该装饰器装饰的任务才会出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from fabric.decorators import roles, parallel</span><br><span class="line">from fabric.api import env, task, hosts, execute, cd, prefix, runs_once, hide</span><br><span class="line">    ...</span><br><span class="line">@task</span><br><span class="line">@roles(&apos;deploy&apos;)</span><br><span class="line">def deploy():</span><br><span class="line">    code_dir = &apos;/srv/django/myproject&apos;</span><br><span class="line">    with settings(warn_only=True):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h1 id="FINALL"><a href="#FINALL" class="headerlink" title="FINALL"></a>FINALL</h1><p>该教程只是简单介绍了fabric以及它的一些常用使用方法，配合python灵活运用可以极大的提升工作效率，如需要深入研究fabric可查看<a href="http://fabric-chs.readthedocs.io/zh_CN/chs/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      <categories>
          
          <category> 运维 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> fabric </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>聊一聊微服务</title>
      <link href="/about_microservice.html"/>
      <url>/about_microservice.html</url>
      <content type="html"><![CDATA[<h1 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h1><blockquote><p>微服务现在受到了大量的关注︰ 文章、 博客、 社交媒体和学术会议上的讨论都能看到该词汇的身影。微服务正迅速走向所指的快速发展期。同时，软件社区的一些怀疑论者指出微服务并不是什么新鲜玩意儿。这些唱反调的人说微服务和SOA概念并没有什么不同，旧瓶装新酒而已，顺势炒炒新概念。然而，不管说是夸大也好，怀疑也罢，微服务架构模式应用在敏捷开发和交付复杂的企业应用程序的时候还是有巨大优势的。</p></blockquote><blockquote><p>一句话总结SOA和微服务的区别，即微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA思想进入单个业务系统内部实现真正的组件化。</p></blockquote><h1 id="微服务的核心思想"><a href="#微服务的核心思想" class="headerlink" title="微服务的核心思想"></a>微服务的核心思想</h1><p>微服务的基本思想在于考虑围绕业务领域组件来创建应用，这些应用可独立的进行开发、管理和加速。在分散的组件中使用微服务云架构和平台使部署、管理和服务功能交付变得更加简单。</p><p>微服务核心包括，其一足够构成一个独立小应用（从DB到UI），其二微服务应用之间只能通过ServiceAPI进行交互，其三一般运行在云虚拟机或更轻的docker容器上。微服务架构的重点就是业务系统需要彻底的组件化和服务化，原有的单个业务系统会拆分成多个可以独立开发，设计，运行和运维的小应用。这些小应用之间通过服务完成交互和集成。</p><p>对于微服务架构下首先仍然是要做好单个组件本身的持续集成，其次在这个基础上增加了多个组件的打包部署和组件间的集成。里面的核心思想就是Devops的思路，希望能够实现开发设计到运维部署的一体化。</p><h1 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h1><p>一个成功的应用总会随着时间逐步成长并变得巨大起来。每个敏捷Sprint周期，开发者会实现更多的功能，当然这就意味着又添加了很多行代码。时间长了后，当年写的小小的单体应用已经变成了巨大的单体怪物。而微服务则在这方面展现出他的优势：</p><ul><li>通过分解巨大单体应用为多个服务方法解决了复杂性问题。同时单个服务很容易开发，理解和维护。</li><li>这种架构使得每个服务都可以有专门开发团队来开发。开发者可以自由选择技术，提供API服务。</li><li>微服务架构使得每个微服务独立部署，开发者不再需要协调其他服务部署对本服务的影响</li><li>微服务架构模式使得每个服务独立扩展。</li></ul><p>微服务的目的是有效的拆分应用，实现敏捷开发和部署。和其他技术一样，微服务架构也有其劣势。</p><ul><li>微服务应用是分布式系统，由此会带来固有的复杂性，开发者需要在RPC或者消息传递之间选择并完成进程间的通讯机制。</li><li>分区的数据库架构，因为更新多个业务主体的事务很普遍。使用分布式事务并不一定是好的选择，不仅仅因为CAP理论，还因为当前高扩展性的nosql和消息传递中间件并不支持这一需求。最终不得不使用一个最终一致性的方法，从而对开发者提出了更高的要求和挑战。</li><li>部署和测试一个基于微服务架构的应用也是一个很复杂的任务</li><li>微服务架构模式应用的改变将会波及多个服务。</li></ul><h1 id="使用API网关构建微服务"><a href="#使用API网关构建微服务" class="headerlink" title="使用API网关构建微服务"></a>使用API网关构建微服务</h1><p>当我们选择把应用构建成一组微服务的时候，我们需要决定应用的客户端如何与这些微服务进行交互。</p><p>理论上客户端可以直接与每一个微服务进行通信，但是这种方案有诸多挑战和限制。</p><ol><li>客户端需求和每个微服务暴露的细粒度API不匹配。简单来说就是一个页面需要发送太多次的api请求，这种方法还使得客户端代码非常复杂。</li><li>部分服务协议对web并不友好</li><li>会使得微服务难以重构，比如未来想要合并，或拆分单个微服务非常困难。</li></ol><p>通常来说，API网关是更好的解决方式。API网关是个服务器，也可以说是进入系统的唯一节点。API网关封装内部系统的架构，并且提供API给各个客户端。它还可能具备授权，监控，负载均衡，缓存，请求分片和管理，静态响应处理等功能。因此，将API网关构建在一个支持异步，I/O非阻塞的平台是合理的。可用使用node.js。</p><p>对于API网关需要实现底层多个细粒度的API组合的场景，推荐采用响应式编程模型进行而不是传统的异步回调方法组合代码。其原因除了采用回调方式导致的代码混乱外，还有就是对于API组合本身可能存在并行或先后调用，对于采用回调方式往往很难控制。同时在实现API网关时，还需要处理局部失败的问题（服务响应慢或不可用的时候）。如果缓存数据可用，API网关还可以返回缓存数据。另外，API网关支持不同的通信机制，包括异步和同步两种类型的进程间通信机制，甚至还可能有同一类型的多种实现。</p><p>总结一下API网关的优缺点：</p><ul><li><p>最大的优点是，它封装了应用程序的内部结构。它和传统ESB的区别就是API网关更加轻量和高性能，他不需要考虑太多遗留系统和诸多协议的适配，其次也不需要考虑服务集成过程中的大量数据转换和映射。</p></li><li><p>缺点是它增加了一个我们必须开发、部署和维护的高可用组件。还有一点是，在我们期望的去中心化和全分布式架构中，API网关又变成了一个中心点或瓶颈点。</p></li></ul><h1 id="微服务中的服务发现"><a href="#微服务中的服务发现" class="headerlink" title="微服务中的服务发现"></a>微服务中的服务发现</h1><p>为了完成一次请求，代码需要知道服务实例的网络地址，对基于云端、现代化的微服务而言，服务实例的网络位置都是动态分配的，所以需要服务发现机制。服务发现分为客户端发现模式和服务端发现模式。</p><h2 id="客户端发现模式"><a href="#客户端发现模式" class="headerlink" title="客户端发现模式"></a>客户端发现模式</h2><p>客户端查询服务注册表（可用服务实例的数据库），用负载均衡算法选择一个实例，发出请求。即如何一个服务的消费都需要分成两个步骤进行，第一步访问服务注册库，第二步客户端与改服务建立连接。<br>缺点：底层ip暴露出来了，需要进一步做安全和防火墙隔离的场景下是不能用的。</p><h2 id="服务端发现模式"><a href="#服务端发现模式" class="headerlink" title="服务端发现模式"></a>服务端发现模式</h2><p>客户端通过负载均衡器向某个服务提出请求，负载均衡器查询注册表，并将请求转发到可用的服务实例。优点是客户端无需发现细节。缺点是负载均衡器是一个需要配置和管理的高可用系统组件。</p><p>服务注册表是服务发现的关键部分，它是一个包含服务实例网络地址的的数据库。一个服务注册表需要高可用和实时更新，客户端可以缓存从服务注册表获取的网络地址。必须多台部署（否则有单点故障），同时要考虑多台机器信息的实时同步和一致。</p><p>服务实例必须在注册表注册和注销。注册和注销有两种不同的方法。一是实例自己注册（更容易实现，但是注册库本身应该具备服务节点心跳检测能力）。另一种是赛用管理服务实例注册的其他系统组件，即第三方注册模式。</p><p>常用的服务注册表例子包括：</p><ul><li>etcd ，一个高可用、分布式、一致性、key-value 方式的存储，被用在分享配置和服务发现中。两个著名的项目使用了它：Kubernetes 和 Cloud Foundry.</li><li>consul ，一个发现和配置服务的工具，为客户端注册和发现服务提供了API，Consul还可以通过执行健康检查决定服务的可用性。</li><li>Apache Zookeeper ，是一个广泛使用、高性能的针对分布式应用的协调服务。 Apache Zookeeper本来是Hadoop的子工程，现在已经是顶级工程了。</li></ul><h1 id="事件驱动的数据管理"><a href="#事件驱动的数据管理" class="headerlink" title="事件驱动的数据管理"></a>事件驱动的数据管理</h1><p>一个单体应用一般只有一个关系型数据库，使用一个关系型数据的优势是应用可以实现ACID。因此，应用可以很简单的开始一个事务，操作（增删改）多条数据，然后提交事务。</p><p>在微服务架构中，每个微服务都有其私有数据库存储，不同的微服务可能使用不同的SQL和NoSQL数据库。这些数据库架构带来便利的同时，也给分布式数据管理带来挑战。一方面是如何实现业务事务，保持多个服务的一致性。另一方面就是如何从多个服务中检索数据，实现查询。</p><p>对于许多应用，解决方案就是事件驱动的架构。在这一架构中，当有显著事件发生时，某个微服务会发布事件，其他微服务则订阅这些事件。当某一微服务接收到事件就可以更新自己的业务实现，实现更多事件被发布。</p><p>事件驱动的优点：它使事务跨多个服务并提供最终一致性。缺点之一在于它的编程模型比ACID事务更加复杂，另外一个劣势就是订阅必须可以检测并忽略重复的事件。另外，事件驱动架构还存在以原子粒度更新数据库并发布事件的问题。</p><h2 id="实现原子化的方案"><a href="#实现原子化的方案" class="headerlink" title="实现原子化的方案"></a>实现原子化的方案</h2><h4 id="采用多步骤本地事务的方法发布事件"><a href="#采用多步骤本地事务的方法发布事件" class="headerlink" title="采用多步骤本地事务的方法发布事件"></a>采用多步骤本地事务的方法发布事件</h4><p>技巧就是有一张event表，更新业务就往event表中插入一条记录，然后提交事务，一个单独应用轮询event表，并根据查询结果来推送。</p><p>这种方案优势是保证了在不使用两段提交前提下事件在每次更新后一定被发布。劣势之一是方案容易出错，程序员必须记得更新后去发布才行，另外一点就是使用nosql时，nosql事务和查询能力有限，实现起来困难。</p><h4 id="挖掘数据库事务日志，然后提交日志实现日志发布"><a href="#挖掘数据库事务日志，然后提交日志实现日志发布" class="headerlink" title="挖掘数据库事务日志，然后提交日志实现日志发布"></a>挖掘数据库事务日志，然后提交日志实现日志发布</h4><p>这种方案的优势在于不使用两段提交的前提下保证了事件一定被发布，事务日志挖掘也可以通过拆分应用业务逻辑事件的发布简化整个应用。劣势是：事务日志每个数据库都不同，甚至同一数据库不同版本也会不同，而且我们很难从低级别的事务日志的更新记录中反推高级别的业务事件。</p><h4 id="使用事件源"><a href="#使用事件源" class="headerlink" title="使用事件源"></a>使用事件源</h4><p>这种方案存储一系列状态变化的事件而不是存储当前实体的状态。一旦业务实体发生变化，一个新的事件就会被添加到事件列表中，由于保存事件是单一操作，本身就是原子性的。</p><p>事件源的优势在于它使得事件发生时可靠的发布事件成为可能，解决了微服务架构中的数据一致性问题。另外一点就是，业务逻辑与交换事件的实体是松耦合的，这使得迁移一个单体应用到微服务架构更加简单</p><p>事件源的劣势子在于，事件数据库对程序员来说很陌生，它仅仅支持主键的方式查询业务实体，必须使用CQRS来实现查询。因此，应用必须处理最终一致性。</p><h1 id="如何重构单体应用到微服务"><a href="#如何重构单体应用到微服务" class="headerlink" title="如何重构单体应用到微服务"></a>如何重构单体应用到微服务</h1><p>从一个现存应用迁移到微服务的过程是应用现代化的一种形式，不应该以从头完全重写的方式把现存应用变为微服务，相反的，应该逐步的把应用重构为一系列的微服务。可以使用三种策略：使用微服务实现新的功能；把表现层从业务逻辑和数据访问组件中拆分出来；把单体应用中的现有模块转化为服务。随着时间推移，微服务的数量将会增长，团队的敏捷性和开发速度也会提升。</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>本文大部分内容源自阅读nginx blog上的大神Chris Richardson发布的<a href="https://www.nginx.com/blog/introduction-to-microservices/" target="_blank" rel="noopener">七篇针对微服务的文章</a>，刚好公司最近正在将一个传统应用迁移至微服务，自己阅读理解的同时将笔记分享出来。</p>]]></content>
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
