<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="golang学习笔记"><meta name="keywords" content=""><meta name="author" content="JASON YOU,undefined"><meta name="copyright" content="JASON YOU"><title>golang学习笔记 | JASONUのBlog</title><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.3"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5b0e70389b44efb0724f113f74fc19ce";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#变量声明"><span class="toc-number">1.</span> <span class="toc-text">变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go语言中的常量"><span class="toc-number">1.1.</span> <span class="toc-text">go语言中的常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型"><span class="toc-number">1.2.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#浮点数的比较"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">浮点数的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map基本用法"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">map基本用法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流程控制"><span class="toc-number">2.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条件控制"><span class="toc-number">2.0.1.</span> <span class="toc-text">条件控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不定参数"><span class="toc-number">3.0.1.</span> <span class="toc-text">不定参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名函数"><span class="toc-number">3.0.2.</span> <span class="toc-text">匿名函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#错误处理"><span class="toc-number">4.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象编程"><span class="toc-number">5.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型系统"><span class="toc-number">5.0.1.</span> <span class="toc-text">类型系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体"><span class="toc-number">5.0.2.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名组合（继承？）"><span class="toc-number">5.0.3.</span> <span class="toc-text">匿名组合（继承？）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性"><span class="toc-number">5.0.4.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">5.0.5.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#接口查询"><span class="toc-number">5.0.5.0.1.</span> <span class="toc-text">接口查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Any类型"><span class="toc-number">5.0.5.0.2.</span> <span class="toc-text">Any类型</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发编程"><span class="toc-number">6.</span> <span class="toc-text">并发编程</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/favicon.ico"></div><div class="author-info__name text-center">JASON YOU</div><div class="author-info__description text-center">JASONUのBlog</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/back.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">JASONUのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">golang学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-19</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h1><p>引入了关键字var，类型信息放在变量名之后，如：</p>
<pre><code>var v1 int 
var v2 *int //指针
</code></pre><p>另外，可以若干变量一起声明：</p>
<pre><code>var {
    v1 int
    v2 string
}
</code></pre><p>变量初始化的时候，var关键字可以保留，但不是    必要元素</p>
<pre><code>var v1 int = 10
var v2 = 10 // 编译器自动推导 v2 的类型
v3 := 10     // 编译器自动推导    v3的类型
</code></pre><p>go编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型，这让go语言看起来有点像动态类型语言，尽管go语言是不折不扣的强类型语言。另外，出现在<code>:=</code>左侧的变量不应该是已经被声明过得，否则会导致编译错误。</p>
<p>go语言支持多重赋值和多重返回，和python类似：</p>
<pre><code>i, j = j, i
_, _, nickname := GetName()
</code></pre><h2 id="go语言中的常量"><a href="#go语言中的常量" class="headerlink" title="go语言中的常量"></a>go语言中的常量</h2><p>常量的定义使用<code>const</code>关键字, 定义时可以限定常量类型，也可以不限制，不限制常量类型的常量是无类型常量，常量定义的右值也可以是一个在编译期运算的常量表达式，比如：<code>const mask = 1 &lt;&lt; 3</code> , 但是常量的右值不能出现需要运行期才能得出结果的表达式，比如<code>const Home = os.GetEnv(&#39;HOME&#39;)</code>,这样会导致编译错误，因为<code>os.GetEnv()</code>只有运行期才能知道返回结果.</p>
<p>go语言预定义常量有：true,false和iota</p>
<p>iota可以被认为是一个可被编辑器修改的常量，在每一次const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其代表对的数字就会自动增1.例如：</p>
<pre><code>const{
    c0 = iota // c0 = 1
    c1 = iota // c1 = 2
    c2 = iota // c2 = 3 
}
const{ // iota被重置为0
    a = 1 &lt;&lt; iota // a = 1
    b            // b = 2
    c            // c = 4
}
</code></pre><p>如果两个const的赋值语句的表达式是一样的，那么可以省略后一个赋值表达式。</p>
<p>另外，同go语言的其他符号(sysbol)一样，以大写字母开头的常量在包外可见。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Go语言内置以下这些基础类型:</p>
<ul>
<li>布尔类型:bool。</li>
<li>整型:int8、byte、int16、int、uint、uintptr等。 </li>
<li>浮点类型:float32、float64。</li>
<li>复数类型:complex64、complex128。 </li>
<li>字符串:string。</li>
<li>字符类型:rune。</li>
<li>错误类型:error。</li>
</ul>
<p>此外，Go语言也支持以下这些复合类型: </p>
<ul>
<li>指针(pointer)</li>
<li>数组(array)</li>
<li>切片(slice)</li>
<li>字典(map)</li>
<li>通道(chan)</li>
<li>结构体(struct) </li>
<li>接口(interface)</li>
</ul>
<p>需要注意的是int和int32在Go语言里被认为是两种不同的类型，编译器也不会帮你自动做类型转换，使用强制类型转换可以解决。当然，开发者在做强制类型转换时，需要注意数据长度被截短而发生的数据精度损失(比如将浮点数强制转为整数)和值溢出(值超过转换的目标类型的值范围时)问题。而且，两个不同类型的整型数不能直接比较，比如int8类型的数和int类型的数不能直接比较。</p>
<h4 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h4><p>因为浮点数不是一种精确的表达方式，所以像整型那样直接用==来判断两个浮点数是否相等 是不可行的，这可能会导致不稳定的结果。下面是一种推荐的替代方案:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;math&quot;</span><br><span class="line">// p为用户自定义的比较精度，比如0.00001 </span><br><span class="line">func IsEqual(f1, f2, p float64) bool &#123;</span><br><span class="line">	return math.Fdim(f1, f2) &lt; p </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个复数z = complex(x, y)，就可以通过Go语言内置函数real(z)获得该复数的实 部，也就是x，通过imag(z)获得该复数的虚部，也就是y。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>golang字符串使用方式和python类似。但是，字符串的内容不能在初始化后被修改。</p>
<p>字符串遍历方式有两种。一种是以字节数组的方式遍历:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str := &quot;Hello,世界&quot;</span><br><span class="line">n := len(str)</span><br><span class="line">for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">        ch := str[i] // 依据下标取字符串中的字符，类型为byte</span><br><span class="line">        fmt.Println(i, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子的输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 72</span><br><span class="line">1 101</span><br><span class="line">2 108</span><br><span class="line">3 108</span><br><span class="line">4 111</span><br><span class="line">5 44</span><br><span class="line">6 32</span><br><span class="line">7 228</span><br><span class="line">8 184</span><br><span class="line">9 150</span><br><span class="line">10 231</span><br><span class="line">11 149</span><br><span class="line">12 140</span><br></pre></td></tr></table></figure>
<p>可以看出，这个字符串长度为13。尽管从直观上来说，这个字符串应该只有9个字符。这是 因为每个中文字符在UTF-8中占3个字节，而不是1个字节。<br>另一种是以Unicode字符遍历:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := &quot;Hello,世界&quot;</span><br><span class="line">for i, ch := range str &#123;</span><br><span class="line">fmt.Println(i, ch)//ch的类型为rune &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 72</span><br><span class="line">1 101</span><br><span class="line">2 108</span><br><span class="line">3 108</span><br><span class="line">4 111</span><br><span class="line">5 44</span><br><span class="line">6 32</span><br><span class="line">7 19990</span><br><span class="line">10 30028</span><br></pre></td></tr></table></figure>
<p>以Unicode字符方式遍历时，每个字符的类型是rune(早期的Go语言用int类型表示Unicode 字符)，而不是byte。在Go语言中支持两个字符类型，一个是byte(实际上是uint8的别名)，代表UTF-8字符串的单个字节的值;另一个是rune，代表单个Unicode字符。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>以下为一些常规的数组声明方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[32]byte // 长度为32的数组，每个元素为一个字节 </span><br><span class="line">[2*N] struct &#123; x, y int32 &#125; // 复杂类型数组</span><br><span class="line">[1000]*float64  // 指针数组</span><br><span class="line">[3][5]int // 二维数组</span><br><span class="line">[2][2][2]float64 // 等同于[2]([2]([2]float64))</span><br></pre></td></tr></table></figure>
<p>从以上类型也可以看出，数组可以是多维的，比如[3][5]int就表达了一个3行5列的二维整 型数组，总共可以存放15个整型元素。<br>在Go语言中，数组长度在定义后就不可更改，在声明时长度可以为一个常量或者一个常量 表达式(常量表达式是指在编译期即可计算结果的表达式)。</p>
<p>Go语言提供了一个关键字range，用于便捷地遍历容器中的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i, v := range array &#123;</span><br><span class="line">	fmt.Println(&quot;Array element[&quot;, i, &quot;]=&quot;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，在Go语言中数组是一个值类型(value type)。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该 参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所 传入数组的一个副本。(和python不同)</p>
<p>关于数组切片，和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该 参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所 传入数组的一个副本。使用数组切片的方式和python类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 先定义一个数组</span><br><span class="line">var myArray [10]int = [10]int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125; </span><br><span class="line">// 基于数组创建一个数组切片</span><br><span class="line">var mySlice []int = myArray[:5]</span><br></pre></td></tr></table></figure>
<p>Go语言提供的内置函数make()可以用于灵活地创建数组切片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mySlice1 := make([]int, 5)</span><br><span class="line">mySlice3 := []int&#123;1, 2, 3, 4, 5&#125;</span><br></pre></td></tr></table></figure>
<p>数组切片支持Go语言内置的cap()函数和len()函数，cap()函数返回的是数组切片分配的空间大小，而len()函数返回的是 数组切片中当前所存储的元素个数。</p>
<p>使用append()函数给数组切片添加元素,函数append()的第二个参数其实是一个不定参数，我们可以按自己需求添加若干个元素，甚至直接将一个数组切片追加到另一个数组切片的末尾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mySlice = append(mySlice, 1, 2, 3)</span><br><span class="line">mySlice2 := []int&#123;8, 9, 10&#125;</span><br><span class="line">// 给mySlice后面添加另一个数组切片</span><br><span class="line">mySlice = append(mySlice, mySlice2...)</span><br></pre></td></tr></table></figure>
<p>数组切片支持Go语言的另一个内置函数copy()，用于将内容从一个数组切片复制到另一个 数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行 复制。</p>
<h4 id="map基本用法"><a href="#map基本用法" class="headerlink" title="map基本用法"></a>map基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">personDB = make(map[string] PersonInfo)</span><br><span class="line">// 往这个map里插入几条数据</span><br><span class="line">personDB[&quot;12345&quot;] = PersonInfo&#123;&quot;12345&quot;, &quot;Tom&quot;, &quot;Room203,...&quot;&#125; personDB[&quot;1&quot;] = PersonInfo&#123;&quot;1&quot;, &quot;Jack&quot;, &quot;Room 101,...&quot;&#125;</span><br><span class="line">// 从这个map查找键为&quot;1234&quot;的信息 </span><br><span class="line">person, ok := personDB[&quot;1234&quot;]</span><br><span class="line">// ok是一个返回的bool型，返回true表示找到了对应的数据 </span><br><span class="line">if ok &#123;</span><br><span class="line">	fmt.Println(&quot;Found person&quot;, person.Name, &quot;with ID 1234.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	fmt.Println(&quot;Did not find person with ID 1234.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map的声明基本上没有多余的元素，比如:<code>var myMap map[string] PersonInfo</code> myMap是声明的map变量名，string是键的类型，PersonInfo则是其中所存放的值类型.我们可以使用Go语言内置的函数make()来创建一个新map。下面的这个例子创建了一个键 类型为string、值类型为PersonInfo的map:<br><code>myMap = make(map[string] PersonInfo)</code></p>
<p>Go语言提供了一个内置函数delete()，用于删除容器内的元素<code>delete(myMap, &quot;1234&quot;)</code>如果“1234”这个键不存在，那么这个调用将什么都不发生，也不会有什么副作用。但是如果传入的map变量的值是nil，该调用将导致 程序抛出异常(panic)</p>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><p>go语言的条件控制语句，需要注意以下几点：</p>
<ul>
<li>条件语句不需要使用括号将条件包含起来();</li>
<li>无论语句体内有几条语句，花括号{}都是必须存在的;</li>
<li>左花括号{必须与if或者else处于同一行;</li>
<li>在if之后，条件语句之前，可以添加变量初始化语句，使用;间隔;</li>
<li>在有返回值的函数中，不允许将“最终的”return语句包含在if…else…结构中，否则会编译失败</li>
</ul>
<p>而switch结构需要注意：</p>
<ul>
<li>左花括号{必须与switch处于同一行;</li>
<li>条件表达式不限制为常量或者整数;</li>
<li>单个case中，可以出现多个结果选项;</li>
<li>与C语言等规则相反，Go语言不需要用break来明确退出一个case;</li>
<li>只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case; 可以不设定switch之后的条件表达式，在此种情况下，整个switch结构与多个if…else…的逻辑作用等同。</li>
</ul>
<p>Go语言的for循环同样支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环，如下例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for j := 0; j &lt; 5; j++ &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">if i &gt; 5 &#123; break JLoop</span><br><span class="line">               &#125;</span><br><span class="line">           fmt.Println(i)</span><br><span class="line">&#125; &#125;</span><br><span class="line">JLoop:</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package mymath import &quot;errors&quot;</span><br><span class="line">func Add(a int, b int) (ret int, err error) &#123;</span><br><span class="line">	if a &lt; 0 || b &lt; 0 &#123; // 假设这个函数只支持两个非负数字的加法</span><br><span class="line">        err= errors.New(&quot;Should be non-negative numbers!&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	return a + b, nil // 支持多重返回值 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果参数列表中若干个相邻的参数类型的相同，比如上面例子中的a和b，则可以在参数列表 中省略前面变量的类型声明.如果返回值列表中多个返回值的类型相同，也可以用同样的方式合并</p>
<h3 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(args ...int) &#123;</span><br><span class="line">	for _, arg := range args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形如…type格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数。它是一 个语法糖(syntactic sugar)，即这种语法对语言的功能并没有影响，但是更方便程序员使用。通 常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的机会。</p>
<p>从内部实现机理上来说，类型…type本质上是一个数组切片，也就是[]type，这也是为 什么上面的参数args可以用for循环来获得每个传入的参数。</p>
<p>不定参数可以原样传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func myfunc(args ...int) &#123; // 按原样传递</span><br><span class="line">        myfunc3(args...)</span><br><span class="line">		// 传递片段，实际上任意的int slice都可以传进去</span><br><span class="line">        myfunc3(args[1:]...)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>之前的例子中将不定参数类型约束为int，如果你希望传任意类型，可以指定类型为 interface{}。下面是Go语言标准库中fmt.Printf()的函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Printf(format string, args ...interface&#123;&#125;) &#123; </span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>golang中的匿名函数可以直接赋值给一个变量或者直接执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f := func(x, y int) int &#123; </span><br><span class="line">	return x + y</span><br><span class="line">&#125;</span><br><span class="line">func(ch chan int) &#123; </span><br><span class="line">	ch &lt;- ACK</span><br><span class="line">&#125; (reply_chan) // 花括号后直接跟参数列表表示函数调用</span><br></pre></td></tr></table></figure>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go语言引入了一个关于错误处理的标准模式，即error接口，该接口的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123; </span><br><span class="line">	Error() string</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>下面用Go库中的实际代码来示范如何使用自定义的error类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type PathError struct &#123; </span><br><span class="line">	Op string</span><br><span class="line">	Path string</span><br><span class="line">	Err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *PathError) Error() string &#123;</span><br><span class="line">	return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go语言使用defer关键字，一个函数中可以存在多个defer语句，因此需要注意的是，defer语句的调用是遵照先进后出的原则，即最后一个defer语句将最先被执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func CopyFile(dst, src string) (w int64, err error) &#123; srcFile, err := os.Open(src)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer srcFile.Close()</span><br><span class="line">	dstFile, err := os.Create(dstName) </span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer dstFile.Close()</span><br><span class="line">	return io.Copy(dstFile, srcFile) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使其中的Copy()函数抛出异常，Go仍然会保证dstFile和srcFile会被正常关闭。</p>
<p>Go语言引入了两个内置函数panic()和recover()以报告和处理运行时错误和程序中的错误场景:</p>
<p>当在一个函数执行过程中调用panic()函数时，正常的函数执行流程将立即终止，但函数中 之前使用defer关键字延迟执行的语句将正常展开执行，之后该函数将返回到调用函数，并导致 逐层向上执行panic流程，直至所属的goroutine中所有正在执行的函数被终止。错误信息将被报 告，包括在调用panic()函数时传入的参数，这个过程称为错误处理流程。</p>
<p>recover()函数用于终止错误处理流程。一般情况下，recover()应该在一个使用defer 关键字的函数中执行以有效截取错误处理流程。如果没有在发生异常的goroutine中明确调用恢复 过程(使用recover关键字)，会导致该goroutine所属的进程打印异常信息后直接退出。</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>Go语言并没有沿 袭传统面向对象编程中的诸多概念，比如继承、虚函数、构造函数和析构函数、隐藏的this指针等。同时，Go语言对面向对象编程的支持是语言类型系统中的天然组成部分。整个类型系统通过接口串联，浑然一体。</p>
<h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>在看go的类型系统前，先看看java的类型系统：</p>
<p>在Java语言中，存在两套完全独立的类型系统:一套是值类型系统，主要是基本类型，如byte、 int、boolean、char、double等，这些类型基于值语义;一套是以Object类型为根的对象类型 系统，这些类型可以定义成员变量和成员方法，可以有虚函数，基于引用语义，只允许在堆上创建(通过使用关键字new)。</p>
<p>Java语言中的Any类型就是整个对象类型系统的根——java.lang.Object 类型，只有对象类型系统中的实例才可以被Any类型引用。值类型想要被Any类型引用，需要装箱 (boxing)过程，比如int类型需要装箱成为Integer类型。另外，只有对象类型系统中的类型才可以实现接口，具体方法是让该类型从要实现的接口继承。</p>
<p>相比之下，Go语言中的大多数类型都是值语义，并且都可以包含对应的操作方法。在需要的时候，你可以给任何类型(包括内置类型)“增加”新方法。而在实现某个接口时，无需从 该接口继承(事实上，Go语言根本就不支持面向对象思想中的继承语法)，只需要实现该接口 要求的所有方法即可。任何类型都可以被Any类型引用。Any类型就是空接口，即interface{}。</p>
<p>例如，我们定义了一个新类型Integer，它和int没有本质不同，只是它为内置的int类型增加了个新方法Less()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Integer int</span><br><span class="line">func (a Integer) Less(b Integer) bool &#123; </span><br><span class="line">	return a &lt; b</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>值语义和引用语义的差别在于赋值，比如下面的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b=a </span><br><span class="line">b.Modify()</span><br></pre></td></tr></table></figure>
<p>如果b的修改不会影响a的值，那么此类型属于值类型。如果会影响a的值，那么此类型是引用类型。Go语言中的大多数类型都基于值语义, 包括数组（和python的list不一样）.Go语言中的数组和基本类型没有区别，是很纯粹的值类型</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>Go语言的结构体(struct)和其他语言的类(class)有同等的地位，但Go语言放弃了包括继 承在内的大量面向对象特性，只保留了组合(composition)这个最基础的特性。</p>
<p>下面代码展示了如何定义并初始化一个类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Rect struct &#123; </span><br><span class="line">	x, y float64</span><br><span class="line">	width, height float64 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *Rect) Area() float64 &#123; </span><br><span class="line">	return r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rect1 := new(Rect)</span><br><span class="line">rect2 := &amp;Rect&#123;&#125;</span><br><span class="line">rect3 := &amp;Rect&#123;0, 0, 100, 200&#125;</span><br><span class="line">rect4 := &amp;Rect&#123;width: 100, height: 200&#125;</span><br></pre></td></tr></table></figure>
<p>在Go语言中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以 NewXXX来命名，表示“构造函数”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func NewRect(x, y, width, height float64) *Rect &#123; </span><br><span class="line">	return &amp;Rect&#123;x, y, width, height&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匿名组合（继承？）"><a href="#匿名组合（继承？）" class="headerlink" title="匿名组合（继承？）"></a>匿名组合（继承？）</h3><p>确切地说，Go语言也提供了继承，但是采用了组合的文法，所以我们将其称为匿名组合:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Base struct &#123; </span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line">func (base *Base) Foo() &#123; ... &#125;</span><br><span class="line">func (base *Base) Bar() &#123; ... &#125;</span><br><span class="line">type Foo struct &#123; </span><br><span class="line">	Base</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">func (foo *Foo) Bar() &#123;</span><br><span class="line">	foo.Base.Bar()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码定义了一个Base类(实现了Foo()和Bar()两个成员方法)，然后定义了一个 Foo类，该类从Base类“继承”并改写了Bar()方法(该方法实现时先调用了基类的Bar() 方法)。</p>
<p>在“派生类”Foo没有改写“基类”Base的成员方法时，相应的方法就被“继承”，例如在 上面的例子中，调用foo.Foo()和调用foo.Base.Foo()效果一致。</p>
<p>另外，在Go语言中，你还可以以指针方式从一个类型“派生”:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Foo struct &#123;</span><br><span class="line">	*Base</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段Go代码仍然有“派生”的效果，只是Foo创建实例的时候，需要外部提供一个Base类 实例的指针。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>Go语言对关键字的增加非常吝啬，其中没有private、protected、public这样的关键字。要使某个符号对其他包(package)可见(即可以访问)，需要将该符号定义为以大写字母开头</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口在Go语言有着至关重要的地位。如果说goroutine和channel是支撑起Go语言的并发模型的基石，让Go语言在如今集群化与多核化的时代成为一道极为亮丽的风景，那么接口是Go语言整个类型系统的基石，让Go语言在基础编程哲学的探索上达到前所未有的高度。</p>
<p>go语言使用非侵入式接口，即类并没有从这些接口继承，甚至可以不知道这些接口的存在，但是Fi类实现了这些接口，可以进行赋值。Go语言的非侵入式接口，看似只是做了很小的文法调整，实则影响深远。</p>
<ul>
<li>其一，Go语言的标准库，再也不需要绘制类库的继承树图。你一定见过不少C++、Java、C# 类库的继承树图</li>
<li>其二，实现类的时候，只需要关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才 合理。接口由使用方按需定义，而不用事前规划</li>
<li>其三，不用为了实现一个接口而导入一个包，因为多引用一个外部的包，就意味着更多的耦 合</li>
</ul>
<h5 id="接口查询"><a href="#接口查询" class="headerlink" title="接口查询"></a>接口查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var file1 Writer = ...</span><br><span class="line">if file5, ok := file1.(two.IStream); ok &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个if语句检查file1接口指向的对象实例是否实现了two.IStream接口，如果实现了，则执 行特定的代码。接口查询是否成功，要在运行期才能够确定。它不像接口赋值，编译器只需要通过静态类型 检查即可判断赋值是否可行。</p>
<p>在Go语言中，还可以更加直截了当地询问接口指向的对象实例的类型，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var v1 interface&#123;&#125; = ... </span><br><span class="line">switch v := v1.(type) &#123;</span><br><span class="line">	case int: // 现在v的类型是int </span><br><span class="line">	case string: // 现在v的类型是string</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h5><p>由于Go语言中任何对象实例都满足空接口interface{}，所以interface{}看起来像是可以指向任何对象的Any类型，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var v1 interface&#123;&#125; = 1</span><br><span class="line">var v2 interface&#123;&#125; = &quot;abc&quot;</span><br><span class="line">var v3 interface&#123;&#125; = &amp;v2</span><br><span class="line">var v4 interface&#123;&#125; = struct&#123; X int &#125;&#123;1&#125;</span><br><span class="line">var v5 interface&#123;&#125; = &amp;struct&#123; X int &#125;&#123;1&#125;</span><br></pre></td></tr></table></figure>
<p>当函数可以接受任意的对象实例时，我们会将其声明为interface{}，最典型的例子是标 准库fmt中PrintXXX系列的函数</p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">JASON YOU</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.pyjason.com/undefined.html">http://www.pyjason.com/undefined.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/images/wei.png"><div class="post-qr-code__desc">微信打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/images/zfb.png"><div class="post-qr-code__desc">支付宝打赏</div></div></div><nav id="pagination"><div class="next-post pull-right"><a href="/bdd_profile.html"><span>BDD行为驱动开发概要</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC8zNTk1MS8xMjQ4Nw=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By JASON YOU</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>